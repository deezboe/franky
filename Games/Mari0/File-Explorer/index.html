<!DOCTYPE html>
<html>
<head>
    <title>IndexedDB Inspector</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .panel { display: flex; gap: 20px; margin-bottom: 20px; }
        #database-list, #object-store-list { width: 200px; border: 1px solid #ddd; padding: 10px; }
        #data-viewer { flex: 1; border: 1px solid #ddd; padding: 10px; }
        .list-item { padding: 5px; cursor: pointer; }
        .list-item:hover { background-color: #f0f0f0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        textarea { width: 100%; height: 100px; }
        button { margin: 5px; padding: 5px 10px; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <h1>IndexedDB Inspector</h1>
    
    <div class="panel">
        <div id="database-list">
            <h3>Databases</h3>
            <div id="databases"></div>
        </div>
        
        <div id="object-store-list">
            <h3>Object Stores</h3>
            <div id="object-stores"></div>
        </div>
        
        <div id="data-viewer">
            <h3 id="data-viewer-title">Data</h3>
            <div id="data-content"></div>
            <div id="edit-form" class="hidden">
                <textarea id="edit-content"></textarea>
                <button id="save-changes">Save Changes</button>
                <button id="cancel-edit">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentDB = null;
        let currentStore = null;
        let currentRecord = null;
        
        // Initialize the inspector
        document.addEventListener('DOMContentLoaded', () => {
            refreshDatabaseList();
            
            // Event listeners
            document.getElementById('save-changes').addEventListener('click', saveChanges);
            document.getElementById('cancel-edit').addEventListener('click', cancelEdit);
        });
        
        // Refresh list of databases
        function refreshDatabaseList() {
            const databasesDiv = document.getElementById('databases');
            databasesDiv.innerHTML = '';
            
            // Get list of databases
            const request = indexedDB.databases();
            
            request.then(dbs => {
                dbs.forEach(db => {
                    const dbItem = document.createElement('div');
                    dbItem.className = 'list-item';
                    dbItem.textContent = db.name;
                    dbItem.setAttribute('data-name', db.name);
                    dbItem.setAttribute('data-version', db.version);
                    
                    dbItem.addEventListener('click', () => {
                        openDatabase(db.name, db.version);
                    });
                    
                    databasesDiv.appendChild(dbItem);
                });
            }).catch(error => {
                console.error('Error getting database list:', error);
                databasesDiv.innerHTML = '<div>Error loading databases</div>';
            });
        }
        
        // Open a specific database
        function openDatabase(name, version) {
            const request = indexedDB.open(name, version);
            
            request.onsuccess = (event) => {
                currentDB = event.target.result;
                displayObjectStores();
            };
            
            request.onerror = (event) => {
                console.error('Database error:', event.target.error);
                alert('Failed to open database');
            };
        }
        
        // Display object stores for the current database
        function displayObjectStores() {
            const storesDiv = document.getElementById('object-stores');
            storesDiv.innerHTML = '';
            
            if (!currentDB) return;
            
            const storeNames = Array.from(currentDB.objectStoreNames);
            
            if (storeNames.length === 0) {
                storesDiv.innerHTML = '<div>No object stores</div>';
                return;
            }
            
            storeNames.forEach(storeName => {
                const storeItem = document.createElement('div');
                storeItem.className = 'list-item';
                storeItem.textContent = storeName;
                storeItem.setAttribute('data-name', storeName);
                
                storeItem.addEventListener('click', () => {
                    currentStore = storeName;
                    displayStoreData();
                });
                
                storesDiv.appendChild(storeItem);
            });
        }
        
        // Display data from the current object store
        function displayStoreData() {
            const contentDiv = document.getElementById('data-content');
            contentDiv.innerHTML = '';
            document.getElementById('data-viewer-title').textContent = `Data: ${currentStore}`;
            
            if (!currentDB || !currentStore) return;
            
            const transaction = currentDB.transaction(currentStore, 'readonly');
            const store = transaction.objectStore(currentStore);
            const request = store.getAll();
            
            request.onsuccess = () => {
                const data = request.result;
                
                if (data.length === 0) {
                    contentDiv.innerHTML = '<div>No records found</div>';
                    return;
                }
                
                // Create table
                const table = document.createElement('table');
                
                // Create header row
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');
                
                // Get all unique property names
                const allKeys = new Set();
                data.forEach(item => {
                    Object.keys(item).forEach(key => allKeys.add(key));
                });
                
                // Add headers
                Array.from(allKeys).forEach(key => {
                    const th = document.createElement('th');
                    th.textContent = key;
                    headerRow.appendChild(th);
                });
                
                // Add action header
                const actionTh = document.createElement('th');
                actionTh.textContent = 'Actions';
                headerRow.appendChild(actionTh);
                
                thead.appendChild(headerRow);
                table.appendChild(thead);
                
                // Create body
                const tbody = document.createElement('tbody');
                
                data.forEach(item => {
                    const row = document.createElement('tr');
                    
                    // Add data cells
                    Array.from(allKeys).forEach(key => {
                        const td = document.createElement('td');
                        const value = item[key];
                        
                        if (value instanceof Blob) {
                            td.textContent = `[Blob ${value.type}]`;
                        } else if (typeof value === 'object' && value !== null) {
                            td.textContent = JSON.stringify(value);
                        } else {
                            td.textContent = value;
                        }
                        
                        row.appendChild(td);
                    });
                    
                    // Add action buttons
                    const actionTd = document.createElement('td');
                    
                    const editButton = document.createElement('button');
                    editButton.textContent = 'Edit';
                    editButton.addEventListener('click', () => editRecord(item));
                    actionTd.appendChild(editButton);
                    
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'Delete';
                    deleteButton.addEventListener('click', () => deleteRecord(item));
                    actionTd.appendChild(deleteButton);
                    
                    row.appendChild(actionTd);
                    tbody.appendChild(row);
                });
                
                table.appendChild(tbody);
                contentDiv.appendChild(table);
            };
            
            request.onerror = () => {
                contentDiv.innerHTML = '<div>Error loading data</div>';
            };
        }
        
        // Edit a record
        function editRecord(record) {
            currentRecord = record;
            const editContent = document.getElementById('edit-content');
            
            // Try to get key path
            let keyPath = null;
            try {
                const store = currentDB.transaction(currentStore).objectStore(currentStore);
                keyPath = store.keyPath;
            } catch (e) {
                console.warn('Could not determine key path:', e);
            }
            
            // Prepare data for editing (exclude key path if it exists)
            const dataToEdit = {...record};
            if (keyPath && typeof keyPath === 'string') {
                delete dataToEdit[keyPath];
            } else if (keyPath && Array.isArray(keyPath)) {
                keyPath.forEach(k => delete dataToEdit[k]);
            }
            
            editContent.value = JSON.stringify(dataToEdit, null, 2);
            document.getElementById('edit-form').classList.remove('hidden');
            document.getElementById('data-content').classList.add('hidden');
        }
        
        // Save changes to a record
        function saveChanges() {
            if (!currentDB || !currentStore || !currentRecord) return;
            
            try {
                const editedData = JSON.parse(document.getElementById('edit-content').value);
                const transaction = currentDB.transaction(currentStore, 'readwrite');
                const store = transaction.objectStore(currentStore);
                
                // Merge changes with original record (preserving key)
                const updatedRecord = {...currentRecord, ...editedData};
                
                const request = store.put(updatedRecord);
                
                request.onsuccess = () => {
                    cancelEdit();
                    displayStoreData();
                };
                
                request.onerror = () => {
                    alert('Error saving changes');
                };
            } catch (e) {
                alert('Invalid JSON: ' + e.message);
            }
        }
        
        // Cancel editing
        function cancelEdit() {
            document.getElementById('edit-form').classList.add('hidden');
            document.getElementById('data-content').classList.remove('hidden');
            currentRecord = null;
        }
        
        // Delete a record
        function deleteRecord(record) {
            if (!currentDB || !currentStore || !confirm('Are you sure you want to delete this record?')) {
                return;
            }
            
            const transaction = currentDB.transaction(currentStore, 'readwrite');
            const store = transaction.objectStore(currentStore);
            
            // Try to get key path
            let keyPath = null;
            try {
                keyPath = store.keyPath;
            } catch (e) {
                console.warn('Could not determine key path:', e);
            }
            
            let key;
            if (keyPath && typeof keyPath === 'string') {
                key = record[keyPath];
            } else if (keyPath && Array.isArray(keyPath)) {
                key = keyPath.map(k => record[k]);
            } else {
                // If no key path, try using the record itself as key
                key = record;
            }
            
            const request = store.delete(key);
            
            request.onsuccess = () => {
                displayStoreData();
            };
            
            request.onerror = () => {
                alert('Error deleting record');
            };
        }
    </script>
</body>
</html>
